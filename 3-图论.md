# 图论

## LCA

+ 倍增

```cpp
vector<int> edge[N];
int fa[N],dep[N],siz[N],son[N];
int top[N],dfn[N],tot;
void dfs1(int x,int f){
	fa[x]=f,dep[x]=dep[f]+1;
	siz[x]=1,son[x]=-1;
	for(int y:edge[x]){
		if(y==f)continue;
		dfs1(y,x);
		siz[x]+=siz[y];
		if(son[x]==-1||siz[y]>siz[son[x]])son[x]=y;
	}
}
void dfs2(int x,int t){
	dfn[x]=++tot;
	top[x]=t;
	if(son[x]==-1)return;
	dfs2(son[x],t);
	for(int y:edge[x]){
		if(y==fa[x]||y==son[x])continue;
		dfs2(y,y);
	}
}
inline int Lca(int x,int y){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(dep[fx]>=dep[fy])x=fa[fx];
		else y=fa[fy];
		fx=top[x],fy=top[y];
	}
	if(dfn[x]<dfn[y])return x;
	else return y;
}
```

## prim
```cpp
const int N = 550, INF = 0x3f3f3f3f;
int n, m, g[N][N];
int d[N], v[N];
int prim() {
    ms(d, 0x3f); //这里的d表示到“最小生成树集合”的距离
    int ans = 0;
    for (int i = 0; i < n; ++ i) { //遍历 n 轮
        int t = -1;
        for (int j = 1; j <= n; ++ j)
            if (v[j] == 0 && (t == -1 || d[j] < d[t])) //如果这个点不在集合内且当前距离集合最近
                t = j;
        v[t] = 1; //将t加入“最小生成树集合”
        if (i && d[t] == INF) return INF; //如果发现不连通，直接返回
        if (i) ans += d[t];
        for (int j = 1; j <= n; ++ j) d[j] = min(d[j], g[t][j]); //用t更新其他点到集合的距离
    }
    return ans;
}
int main() {
    ms(g, 0x3f); cin >> n >> m;
    while (m -- ) {
        int x, y, w; cin >> x >> y >> w;
        g[x][y] = g[y][x] = min(g[x][y], w);
    }
    int t = prim();
    if (t == INF) cout << "impossible" << endl;
    else cout << t << endl;
} //22.03.19已测试
```

## 二分图
最大独立集=总点数−最小点覆盖(集合)
最大权闭合子图=正点权和−最小割(构造)
对于正价点,连源,边权为点权。对应地,负价点连汇,边权为(负)点权。
原图中的有向边保留,边权置为INF

最小路径覆盖=总点数−拆点二分图最大匹配

HopcroftKarp算法（基于最大流）解
```cpp
struct HopcroftKarp {
    int n, m;
    vector<array<int, 2>> ver;
    vector<int> l, r;

    HopcroftKarp(int n, int m) : n(n), m(m) { // 左右半部
        l.assign(n, -1);
        r.assign(m, -1);
    }
    void add(int x, int y) {
        x--, y--; // 这个板子是 0-idx 的
        ver.push_back({x, y});
    }
    int work() {
        vector<int> adj(ver.size());

        mt19937 rgen(chrono::steady_clock::now().time_since_epoch().count());
        shuffle(ver.begin(), ver.end(), rgen); // 随机化防卡

        vector<int> deg(n + 1);
        for (auto &[u, v] : ver) {
            deg[u]++;
        }
        for (int i = 1; i <= n; i++) {
            deg[i] += deg[i - 1];
        }
        for (auto &[u, v] : ver) {
            adj[--deg[u]] = v;
        }

        int ans = 0;
        vector<int> a, p, q(n);
        while (true) {
            a.assign(n, -1), p.assign(n, -1);

            int t = 0;
            for (int i = 0; i < n; i++) {
                if (l[i] == -1) {
                    q[t++] = a[i] = p[i] = i;
                }
            }

            bool match = false;
            for (int i = 0; i < t; i++) {
                int x = q[i];
                if (~l[a[x]]) continue;

                for (int j = deg[x]; j < deg[x + 1]; j++) {
                    int y = adj[j];
                    if (r[y] == -1) {
                        while (~y) {
                            r[y] = x;
                            swap(l[x], y);
                            x = p[x];
                        }
                        match = true;
                        ++ans;
                        break;
                    }
                    if (p[r[y]] == -1) {
                        q[t++] = y = r[y];
                        p[y] = x;
                        a[y] = a[x];
                    }
                }
            }
            if (!match) break;
        }
        return ans;
    }
    vector<array<int, 2>> answer() {
        vector<array<int, 2>> ans;
        for (int i = 0; i < n; i++) {
            if (~l[i]) {
                ans.push_back({i, l[i]});
            }
        }
        return ans;
    }
};

signed main() {
    int n1, n2, m;
    cin >> n1 >> n2 >> m;
    HopcroftKarp flow(n1, n2);
    while (m--) {
        int x, y;
        cin >> x >> y;
        flow.add(x, y);
    }

    cout << flow.work() << "\n";

    auto match = flow.answer();
    for (auto [u, v] : match) {
        cout << u << " " << v << "\n";
    }
}
```

## 欧拉路径/欧拉回路 Hierholzers
有向图欧拉路径存在判定
有向图欧拉路径存在：恰有一个点出度比入度多 1（为起点）恰有一个点入度比出度多 1（为终点)恰有 N−2个点入度均等于出度。如果是欧拉回路，则上方起点与终点的条件不存在，全部点均要满足最后一个条件。
无向图欧拉路径存在判定
无向图欧拉路径存在：恰有两个点度数为奇数（为起点与终点）.恰有 N−2个点度数为偶数。
有向图欧拉路径求解（字典序最小）:
```cpp
vector<int> ans;
auto dfs = [&](auto self, int x) -> void {
    while (ver[x].size()) {
        int net = *ver[x].begin();
        ver[x].erase(ver[x].begin());
        self(self, net);
    }
    ans.push_back(x);
};
dfs(dfs, s);
reverse(ans.begin(), ans.end());
for (auto it : ans) {
    cout << it << " ";
}
```

