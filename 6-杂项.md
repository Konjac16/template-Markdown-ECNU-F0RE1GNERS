#  杂项

## 树上莫队

```cpp
const int N=300005;
int n,m;
vector<int> edge[N];
int fa[N],dep[N],siz[N],son[N];
int top[N],dfn[N],tot;
int rnk[N],Fir[N],Sec[N],cnt;
void dfs1(int x,int f){
	fa[x]=f,dep[x]=dep[f]+1;
	siz[x]=1,son[x]=-1;
	rnk[++cnt]=x,Fir[x]=cnt;
	for(int y:edge[x]){
		if(y==f)continue;
		dfs1(y,x);
		siz[x]+=siz[y];
		if(son[x]==-1||siz[y]>siz[son[x]])son[x]=y;
	}rnk[++cnt]=x,Sec[x]=cnt;
}
void dfs2(int x,int t){
	top[x]=t,dfn[x]=++tot;
	if(son[x]==-1)return;
	dfs2(son[x],t);
	for(int y:edge[x]){
		if(y==fa[x]||y==son[x])continue;
		dfs2(y,y);
	}
}
inline int Lca(int x,int y){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(dep[fx]>=dep[fy])x=fa[fx];
		else y=fa[fy];
		fx=top[x],fy=top[y];
	}
	if(dfn[x]<dfn[y])return x;
	else return y;
}
int bel[N];
int a[N],b[N],lsh;
int ans[N];
struct node{int l,r,lca,id;}q[N];
inline bool cmp(node a,node b){
	return (bel[a.l]^bel[b.l])?(bel[a.l]<bel[b.l]):((bel[a.l]&1)?a.r<b.r:a.r>b.r);
}
int vis[N],Cnt[N];
int now;
inline void cal(int pos){
	vis[pos]?(now-=!--Cnt[a[pos]]):(now+=!Cnt[a[pos]]++);
	vis[pos]^=1;
}
signed main()
{
	n=read(),m=read();
	For(i,1,n)a[i]=read(),b[i]=a[i];
	sort(b+1,b+n+1);
	lsh=unique(b+1,b+n+1)-(b+1);
	For(i,1,n)a[i]=lower_bound(b+1,b+lsh+1,a[i])-b;
	For(i,1,n-1){
		int u=read(),v=read();
		edge[u].push_back(v);
		edge[v].push_back(u);
	}dfs1(1,1);dfs2(1,1);
	int SZ=sqrt(2*n);For(i,1,2*n)bel[i]=i/SZ;
	For(i,1,m){
		int l=read(),r=read(),lca=Lca(l,r);
		if(Fir[l]>Fir[r])swap(l,r);
		if(l==lca)q[i]=node{Fir[l],Fir[r],0,i};
		else q[i]=node{Sec[l],Fir[r],lca,i};
	}sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	For(i,1,m){
		int L=q[i].l,R=q[i].r,lca=q[i].lca;
		while(r<R)cal(rnk[++r]);
		while(r>R)cal(rnk[r--]);
		while(l>L)cal(rnk[--l]);
		while(l<L)cal(rnk[l++]);
		if(lca)cal(lca);
		ans[q[i].id]=now;
		if(lca)cal(lca);
	}
	For(i,1,m)write(ans[i],'\n');

	return 0;
}
/*

*/
```
