#  杂项

## 树上莫队
st[i] 为 i 加入到欧拉序的时间，ed[i] 为回溯时 i 加入欧拉序的时间
设 st[x]<st[y]

若 lca(x,y)=x，则 x,y 在一条链上，在 st[x]~st[y] 这段区间中，有的点出现了两次，有的店没有出现过，这些点都是对答案无贡献的，我们只需要统计出现 1 次的点就好。

若 lca(x,y)!=x，此时 x,y 位于不同子树内，我们只需要按照上面的方法统计 ed[x]~st[y] 这段区间内的点。

同时，注意特判 lca。
```cpp
const int N=300005;
int n,m;
vector<int> edge[N];
int fa[N],dep[N],siz[N],son[N];
int top[N],dfn[N],tot;
int rnk[N],Fir[N],Sec[N],cnt;
void dfs1(int x,int f){
	fa[x]=f,dep[x]=dep[f]+1;
	siz[x]=1,son[x]=-1;
	rnk[++cnt]=x,Fir[x]=cnt;
	for(int y:edge[x]){
		if(y==f)continue;
		dfs1(y,x);
		siz[x]+=siz[y];
		if(son[x]==-1||siz[y]>siz[son[x]])son[x]=y;
	}rnk[++cnt]=x,Sec[x]=cnt;
}
void dfs2(int x,int t){
	top[x]=t,dfn[x]=++tot;
	if(son[x]==-1)return;
	dfs2(son[x],t);
	for(int y:edge[x]){
		if(y==fa[x]||y==son[x])continue;
		dfs2(y,y);
	}
}
inline int Lca(int x,int y){
	int fx=top[x],fy=top[y];
	while(fx!=fy){
		if(dep[fx]>=dep[fy])x=fa[fx];
		else y=fa[fy];
		fx=top[x],fy=top[y];
	}
	if(dfn[x]<dfn[y])return x;
	else return y;
}
int bel[N];
int a[N],b[N],lsh;
int ans[N];
struct node{int l,r,lca,id;}q[N];
inline bool cmp(node a,node b){
	return (bel[a.l]^bel[b.l])?(bel[a.l]<bel[b.l]):((bel[a.l]&1)?a.r<b.r:a.r>b.r);
}
int vis[N],Cnt[N];
int now;
inline void cal(int pos){
	vis[pos]?(now-=!--Cnt[a[pos]]):(now+=!Cnt[a[pos]]++);
	vis[pos]^=1;
}
signed main()
{
	n=read(),m=read();
	For(i,1,n)a[i]=read(),b[i]=a[i];
	sort(b+1,b+n+1);
	lsh=unique(b+1,b+n+1)-(b+1);
	For(i,1,n)a[i]=lower_bound(b+1,b+lsh+1,a[i])-b;
	For(i,1,n-1){
		int u=read(),v=read();
		edge[u].push_back(v);
		edge[v].push_back(u);
	}dfs1(1,1);dfs2(1,1);
	int SZ=sqrt(2*n);For(i,1,2*n)bel[i]=i/SZ;
	For(i,1,m){
		int l=read(),r=read(),lca=Lca(l,r);
		if(Fir[l]>Fir[r])swap(l,r);
		if(l==lca)q[i]=node{Fir[l],Fir[r],0,i};
		else q[i]=node{Sec[l],Fir[r],lca,i};
	}sort(q+1,q+m+1,cmp);
	int l=1,r=0;
	For(i,1,m){
		int L=q[i].l,R=q[i].r,lca=q[i].lca;
		while(r<R)cal(rnk[++r]);
		while(r>R)cal(rnk[r--]);
		while(l>L)cal(rnk[--l]);
		while(l<L)cal(rnk[l++]);
		if(lca)cal(lca);
		ans[q[i].id]=now;
		if(lca)cal(lca);
	}
	For(i,1,m)write(ans[i],'\n');

	return 0;
}
```

## 带悔贪心
cyrcyr 今天在种树，他在一条直线上挖了 $n$ 个坑。这 $n$ 个坑都可以种树，但为了保证每一棵树都有充足的养料，cyrcyr 不会在相邻的两个坑中种树。而且由于 cyrcyr 的树种不够，他至多会种 $k$ 棵树。假设 cyrcyr 有某种神能力，能预知自己在某个坑种树的获利会是多少（可能为负），请你帮助他计算出他的最大获利。

```cpp
int n,k;
struct node{
	int x,id;
}a[N];
bool operator<(node A,node B){return A.x<B.x;}
priority_queue<node> q;
int L[N],R[N];
int vis[N];
inline void del(int x){
	L[x]=L[L[x]];
	R[x]=R[R[x]];
	R[L[x]]=x;
	L[R[x]]=x;
}
inline void work(){
	n=read(),k=read();
	For(i,1,n){
		a[i].x=read(),a[i].id=i;
		q.push(a[i]);
		L[i]=i-1; if(i!=n)R[i]=i+1;
	}
	int ans=0,res=0;
	For(i,1,k){
		while(vis[q.top().id])q.pop();
		node tt=q.top(); q.pop();
		res+=tt.x; ans=max(ans,res);
		int _L=L[tt.id],_R=R[tt.id];
		a[tt.id].x=a[_L].x+a[_R].x-tt.x;
		vis[_L]=vis[_R]=1;
		q.push(a[tt.id]);
		del(tt.id);
	}
	write(ans,'\n');
}
```
