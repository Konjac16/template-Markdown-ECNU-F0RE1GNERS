# 数学

## 类欧几里得

* $m = \lfloor \frac{an+b}{c} \rfloor$.
* $f(a,b,c,n)=\sum_{i=0}^n\lfloor\frac{ai+b}{c}\rfloor$: 当 $a \ge c$ or $b \ge c$ 时，$f(a,b,c,n)=(\frac{a}{c})n(n+1)/2+(\frac{b}{c})(n+1)+f(a \bmod c,b \bmod c,c,n)$；否则 $f(a,b,c,n)=nm-f(c,c-b-1,a,m-1)$。
* $g(a,b,c,n)=\sum_{i=0}^n i \lfloor\frac{ai+b}{c}\rfloor$: 当 $a \ge c$ or $b \ge c$ 时，$g(a,b,c,n)=(\frac{a}{c})n(n+1)(2n+1)/6+(\frac{b}{c})n(n+1)/2+g(a \bmod c,b \bmod c,c,n)$；否则 $g(a,b,c,n)=\frac{1}{2} (n(n+1)m-f(c,c-b-1,a,m-1)-h(c,c-b-1,a,m-1))$。
* $h(a,b,c,n)=\sum_{i=0}^n\lfloor \frac{ai+b}{c} \rfloor^2$: 当 $a \ge c$ or $b \ge c$ 时，$h(a,b,c,n)=(\frac{a}{c})^2 n(n+1)(2n+1)/6 +(\frac{b}{c})^2 (n+1)+(\frac{a}{c})(\frac{b}{c})n(n+1)+h(a \bmod c, b \bmod c,c,n)+2(\frac{a}{c})g(a \bmod c,b \bmod c,c,n)+2(\frac{b}{c})f(a \bmod c,b \bmod c,c,n)$；否则 $h(a,b,c,n)=nm(m+1)-2g(c,c-b-1,a,m-1)-2f(c,c-b-1,a,m-1)-f(a,b,c,n)$。

## excrt
```cpp
int n,m;
int a[N],b[N];
int exgcd(int a,int b,int &x,int &y){
	if(b==0){x=1,y=0;return a;}
	int d=exgcd(b,a%b,x,y);
	int z=x;x=y,y=z-a/b*y;
	
	return d;
}
inline int mul(int a,int b,int mod){
	int res=0;
	for(;b;b>>=1){
		if(b&1)res=(res+a)%mod;
		a=(a<<1)%mod;
	}
	return res;
}
inline int excrt(){
	int ans=b[1];m=a[1];
	For(i,2,n){
		int t,y,c=((b[i]-ans)%a[i]+a[i])%a[i];
		int d=exgcd(m,a[i],t,y);
		// t=t*(c/d);
		t=mul(t,c/d,a[i]);
		ans+=t*m;
		m=lcm(m,a[i]);
		ans=(ans%m+m)%m;
	}
	int res=(ans%m+m)%m;
	return res;
}
signed main()
{
	n=read();
	For(i,1,n)a[i]=read(),b[i]=read();
	write(excrt());
	return 0;
}
/*
x=b[i](mod a[i])
*/
```

## gauss

```cpp
int n,m;
double a[N][N];
inline void gauss(){
	For(i,1,n){
		int F=0;
		For(j,i,n)if(a[j][i]){
			For(k,1,m)swap(a[i][k],a[j][k]);
			F=1; break;
		}
		if(!F)For(j,1,i-1)if(a[j][i]&&a[i][i]==0){
			For(k,1,m)swap(a[i][k],a[j][k]);
			F=1; break;	
		}
		if(!F)continue;
		double tt=a[i][i];
		For(k,i,m)a[i][k]/=tt;
		For(j,1,n)if(j!=i){
			tt=a[j][i];
			For(k,i,m)a[j][k]-=tt*a[i][k];
		}
	}
	For(i,1,n)if(a[i][i]==0&&a[i][m]){write(-1,'\n');return;}
	For(i,1,n)if(a[i][i]==0&&a[i][m]==0){write(0,'\n');return;}
	For(i,1,n)printf("x%lld=%0.2lf\n",i,a[i][m]);
}
signed main()
{
	n=read(),m=n+1;
	For(i,1,n)For(j,1,m)cin>>a[i][j];
	gauss();
	return 0;
}
/*
a[1][1]*x1+a[1][2]*x2+...+a[1][n]*xn=b1
a[2][1]*x1+a[2][2]*x2+...+a[2][n]*xn=b2
无解-1
无穷解0
*/
```
## 线性筛
```cpp
phi[1]=1,mu[1]=1;
For(i,2,N-1){
  if(!vis[i]){p[++tot]=i,phi[i]=i-1,mu[i]=-1;}
  for(int j=1;j<=tot&&i*p[j]<N;++j){
    vis[i*p[j]]=1;
    if(i%p[j]!=0){
      phi[i*p[j]]=phi[i]*(p[j]-1);
      mu[i*p[j]]=-mu[i];
    }else{
      phi[i*p[j]]=phi[i]*p[j],mu[i*p[j]]=0;
      break;
    }
  }
}
```

## 二元一次方程 Ax+By=C
```cpp
auto clac = [&](int a, int b, int c) {
    int u = 1, v = 1;
    if (a < 0) { // 负数特判，但是没用经过例题测试
        a = -a;
        u = -1;
    }
    if (b < 0) {
        b = -b;
        v = -1;
    }

    int x, y, d = exgcd(a, b, x, y), ans;
    if (c % d != 0) { // 无整数解
        cout << -1 << "\n";
        return;
    }
    a /= d, b /= d, c /= d;
    x *= c, y *= c; // 得到可行解

    ans = (x % b + b - 1) % b + 1;
    auto [A, B] = pair{u * ans, v * (c - ans * a) / b}; // x最小正整数 特解

    ans = (y % a + a - 1) % a + 1;
    auto [C, D] = pair{u * (c - ans * b) / a, v * ans}; // y最小正整数 特解
    
    int num = (C - A) / b + 1; // xy均为正整数 的 解的组数
};
```

## 求解连续按位异或
O(1) 0^1^2^...^n
```cpp
unsigned xor_n(unsigned n) {
    unsigned t = n & 3;
    if (t & 1) return t / 2u ^ 1;
    return t / 2u ^ n;
}
```
```cpp
i64 xor_n(i64 n) {
    if (n % 4 == 1) return 1;
    else if (n % 4 == 2) return n + 1;
    else if (n % 4 == 3) return 0;
    else return n;
}
```
## Miller - Rabin 素数测试
$O(4log^3x)$，这里可以看错 O(1)
```cpp
int mul(int a, int b, int m) {
    int r = a * b - m * (int)(1.L / m * a * b);
    return r - m * (r >= m) + m * (r < 0);
}
int mypow(int a, int b, int m) {
    int res = 1 % m;
    for (; b; b >>= 1, a = mul(a, a, m)) {
        if (b & 1) {
            res = mul(res, a, m);
        }
    }
    return res;
}

int B[] = {2, 3, 5, 7, 11, 13, 17, 19, 23};
bool MR(int n) {
    if (n <= 1) return 0;
    for (int p : B) {
        if (n == p) return 1;
        if (n % p == 0) return 0;
    }
    int m = (n - 1) >> __builtin_ctz(n - 1);
    for (int p : B) {
        int t = m, a = mypow(p, m, n);
        while (t != n - 1 && a != 1 && a != n - 1) {
            a = mul(a, a, n);
            t *= 2;
        }
        if (a != n - 1 && t % 2 == 0) return 0;
    }
    return 1;
}
```
## Pollard - Rho 因式分解
以单个因子O(logX)的复杂度输出数字 X 的全部质因数，由于需要结合素数测试，总复杂度会略高一些。如果遇到超时的情况，可能需要考虑进一步优化，例如检查题目是否强制要求枚举全部质因数等等
```cpp
int PR(int n) {
    for (int p : B) {
        if (n % p == 0) return p;
    }
    auto f = [&](int x) -> int {
        x = mul(x, x, n) + 1;
        return x >= n ? x - n : x;
    };
    int x = 0, y = 0, tot = 0, p = 1, q, g;
    for (int i = 0; (i & 255) || (g = gcd(p, n)) == 1; i++, x = f(x), y = f(f(y))) {
        if (x == y) {
            x = tot++;
            y = f(x);
        }
        q = mul(p, abs(x - y), n);
        if (q) p = q;
    }
    return g;
}
vector<int> fac(int n) {
    #define pb emplace_back
    if (n == 1) return {};
    if (MR(n)) return {n};
    int d = PR(n);
    auto v1 = fac(d), v2 = fac(n / d);
    auto i1 = v1.begin(), i2 = v2.begin();
    vector<int> ans;
    while (i1 != v1.end() || i2 != v2.end()) {
        if (i1 == v1.end()) {
            ans.pb(*i2++);
        } else if (i2 == v2.end()) {
            ans.pb(*i1++);
        } else {
            if (*i1 < *i2) {
                ans.pb(*i1++);
            } else {
                ans.pb(*i2++);
            }
        }
    }
    return ans;
}
```
